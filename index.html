<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>增强版AI五子棋 (Python/Vercel)</title> <style>
/* CSS 与之前相同 */
body { font-family: sans-serif; text-align: center; }
canvas { border:1px solid #333; margin-top:10px; cursor:pointer; display: block; margin-left: auto; margin-right: auto;}
#status { margin-top:10px; font-size: 1.2em; min-height: 1.5em; }
button { margin: 5px; padding: 8px 15px; font-size: 1em;}
.difficulty-selector { margin: 15px 0; }
.difficulty-selector label { margin: 0 10px; }
.thinking-indicator {
    display: none; /* Hidden by default */
    margin-left: 10px;
    font-style: italic;
    color: #555;
}
.thinking #status .thinking-indicator {
    display: inline; /* Show when thinking */
}
</style>
</head>
<body>
<h1>增强版AI五子棋 (Python/Vercel)</h1> <div class="difficulty-selector">
  <span>选择难度:</span>
  <label><input type="radio" name="difficulty" value="2" onclick="setDifficulty(2)"> 简单</label>
  <label><input type="radio" name="difficulty" value="3" checked onclick="setDifficulty(3)"> 普通 (默认)</label>
  <label><input type="radio" name="difficulty" value="4" onclick="setDifficulty(4)"> 困难</label>
  <label><input type="radio" name="difficulty" value="5" onclick="setDifficulty(5)"> 极难 (可能较慢)</label>
  </div>

<canvas id="board" width="600" height="600"></canvas>
<div id="status">您的回合<span class="thinking-indicator"> (AI 思考中...)</span></div>
<button onclick="resetGame()">重新开始</button>
<button onclick="aiFirst()">AI先手</button>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const size = 15;
const cell = canvas.width / size;
let board = Array.from({length:size}, ()=>Array(size).fill(0));
let gameOver = false;
let playerTurn = true;
let currentDepth = 3;
// --- 重要修改：使用相对路径 ---
const AI_BACKEND_URL = '/ai_move'; // Use relative path for Vercel

// --- 绘制、游戏逻辑、事件监听器 (与之前相同) ---
function drawBoard() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#f0d9b5"; ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle="#333"; ctx.lineWidth = 1;
  for(let i=0;i<size;i++){
    ctx.beginPath(); ctx.moveTo(cell/2, cell/2 + i*cell); ctx.lineTo(canvas.width - cell/2, cell/2 + i*cell); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cell/2 + i*cell, cell/2); ctx.lineTo(cell/2 + i*cell, canvas.height - cell/2); ctx.stroke();
  }
  const starPoints = [ [3, 3], [11, 3], [3, 11], [11, 11], [7, 7] ];
  ctx.fillStyle = "#333";
  starPoints.forEach(([x, y]) => { ctx.beginPath(); ctx.arc(cell / 2 + x * cell, cell / 2 + y * cell, cell * 0.1, 0, Math.PI * 2); ctx.fill(); });
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(board[y][x]!==0){
        let color = board[y][x] === 1 ? "black" : "#D80000";
        ctx.beginPath(); ctx.arc(cell/2 + x*cell, cell/2 + y*cell, cell*0.4, 0, Math.PI*2); ctx.fillStyle=color;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)'; ctx.shadowBlur = 3; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
        ctx.fill();
        ctx.shadowColor = 'transparent';
      }
    }
  }
}
function checkWin(x,y,player){
  if(x<0 || y<0 || x>=size || y>=size || board[y][x] !== player) return false;
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let count=1;
    for(let i=1;i<5;i++){ let nx=x+i*dx, ny=y+i*dy; if(nx<0||ny<0||nx>=size||ny>=size || board[ny][nx] !== player) break; count++; }
    for(let i=1;i<5;i++){ let nx=x-i*dx, ny=y-i*dy; if(nx<0||ny<0||nx>=size||ny>=size || board[ny][nx] !== player) break; count++; }
    if(count>=5) return true;
  }
  return false;
}
function isFull(){ return board.every(row=>row.every(cell=>cell!==0)); }

canvas.addEventListener('click',function(e){
  if(gameOver || !playerTurn) return;
  const rect=canvas.getBoundingClientRect();
  let x=Math.floor((e.clientX - rect.left)/cell);
  let y=Math.floor((e.clientY - rect.top)/cell);
  if(x<0||y<0||x>=size||y>=size||board[y][x]!==0) return;
  board[y][x]=1; drawBoard();
  if(checkWin(x,y,1)){ setStatus("恭喜你赢了！🎉"); gameOver=true; return; }
  if(isFull()){ setStatus("平局！🤝"); gameOver=true; return; }
  playerTurn = false;
  setStatus("AI思考中...🤔", true);
  setTimeout(requestAiMove, 50);
});

async function requestAiMove() {
    if (gameOver) return;
    console.log("Requesting AI move from backend:", AI_BACKEND_URL); // Log the URL being used
    try {
        const response = await fetch(AI_BACKEND_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({ board: board, depth: currentDepth })
        });
        // Log raw response status
        console.log("Backend response status:", response.status);

        // Try parsing JSON regardless of status for error messages
        const data = await response.json().catch(err => {
            console.error("Failed to parse JSON response:", err);
            return { error: `无效的响应 (${response.status})` }; // Provide fallback error
        });

        // Log the parsed data
        console.log("Backend response data:", data);

        if (!response.ok) {
            console.error(`Backend Error: ${response.status}`, data);
            setStatus(`AI 错误: ${data.error || response.statusText} 😭`);
            playerTurn = true; // Maybe give turn back to player on error?
            setStatus("AI出错了，请重试. 您的回合");
            return;
        }
        if (data.error) {
             console.error("Backend returned an error:", data.error);
             setStatus(`AI 错误: ${data.error} 😭`);
             playerTurn = true; // Give turn back
             setStatus("AI出错了，请重试. 您的回合");
             return;
        }
        if (data.move && typeof data.move.x === 'number' && typeof data.move.y === 'number') {
            const { x, y } = data.move;
             if (y < 0 || y >= size || x < 0 || x >= size || board[y][x] !== 0) {
                 console.error(`Backend returned invalid move: (${x}, ${y}). Cell empty? ${board[y]?.[x] === 0}`);
                setStatus("AI 返回了无效的移动! 🤯");
                playerTurn = true; // Give turn back
                setStatus("AI出错了，请重试. 您的回合");
                return;
             }
            console.log(`AI move received: (${x}, ${y})`);
            board[y][x] = 2; drawBoard();
            if (checkWin(x, y, 2)) { setStatus("AI赢了！🤖"); gameOver = true; return; }
            if (isFull()) { setStatus("平局！🤝"); gameOver = true; return; }
            playerTurn = true; setStatus("您的回合");
        } else {
            console.error("Invalid move data from backend:", data);
            setStatus("AI响应格式错误! 😵");
            playerTurn = true; // Give turn back
            setStatus("AI出错了，请重试. 您的回合");
        }
    } catch (error) {
        console.error('Network error or fetch failed:', error);
        setStatus("无法连接到AI服务器! 🔌");
        playerTurn = true; // Give turn back
        setStatus("连接错误，请重试. 您的回合");
    }
}

// --- 控制函数 (setStatus, resetGame, setDifficulty, aiFirst - 与之前相同) ---
function setStatus(message, isThinking = false) {
    const statusDiv = document.getElementById('status');
    const textSpan = statusDiv.firstChild;
    textSpan.nodeValue = message;
    if (isThinking) { statusDiv.classList.add('thinking'); }
    else { statusDiv.classList.remove('thinking'); }
}
function resetGame(){
  board = Array.from({length:size},()=>Array(size).fill(0));
  gameOver = false; playerTurn = true; drawBoard(); setStatus("游戏重置，您的回合");
}
function setDifficulty(level) {
    currentDepth = parseInt(level, 10); console.log(`难度设置为: ${level}, 搜索深度: ${currentDepth}`);
    resetGame(); setStatus(`难度已切换 (${level})，游戏重置，您的回合`);
}
function aiFirst() {
    resetGame(); playerTurn = false; setStatus("AI先手，思考中...🤔", true);
    setTimeout(requestAiMove, 50);
}

// --- Initial Setup ---
drawBoard();
document.querySelector(`input[name="difficulty"][value="${currentDepth}"]`).checked = true;
</script>
</body>
</html>